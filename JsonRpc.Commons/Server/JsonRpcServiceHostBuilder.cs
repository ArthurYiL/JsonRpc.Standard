using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using JsonRpc.Contracts;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace JsonRpc.Server
{
    /// <summary>
    /// A builder for <see cref="IJsonRpcServiceHost"/>.
    /// </summary>
    public sealed class JsonRpcServiceHostBuilder
    {
        private readonly IList<Type> serviceTypes = new List<Type>();

        private readonly IList<Func<RequestHandler, RequestHandler>> interceptions =
            new List<Func<RequestHandler, RequestHandler>>();

        public JsonRpcServiceHostBuilder()
        {

        }
 
        /// <summary>
        /// The factory that creates the JSON RPC service instances to handle the requests.
        /// </summary>
        public IServiceFactory ServiceFactory { get; set; }

        /// <summary>
        /// Contract resolver that maps the JSON RPC methods to CLR service methods.
        /// </summary>
        public IJsonRpcContractResolver ContractResolver { get; set; }

        /// <summary>
        /// The binder that chooses the best match among a set of RPC methods.
        /// </summary>
        public IJsonRpcMethodBinder MethodBinder { get; set; }

        /// <summary>
        /// The logger factory used to get a logger for the service host.
        /// </summary>
        /// <remarks>If you want to completely disable the logging, set this property to an empty LoggerFactory instance.</remarks>
        public ILoggerFactory LoggerFactory { get; set; }

        /// <summary>
        /// Registers all the exposed JSON PRC methods in the public service object types contained in the specified assembly.
        /// </summary>
        /// <param name="assembly">An assembly.</param>
        /// <exception cref="ArgumentNullException"><paramref name="assembly"/> is <c>null</c>.</exception>
        public void Register(Assembly assembly)
        {
            foreach (var t in assembly.ExportedTypes
                .Where(t => typeof(JsonRpcService).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo())))
                Register(t);
        }

        /// <summary>
        /// Registers all the exposed JSON PRC methods in the specified service object type.
        /// </summary>
        /// <param name="serviceType">A subtype of <see cref="JsonRpcService"/>.</param>
        /// <exception cref="ArgumentNullException"><paramref name="serviceType"/> is <c>null</c>.</exception>
        /// <exception cref="ArgumentException"><paramref name="serviceType"/> is not a derived type from <see cref="JsonRpcService"/>.</exception>
        public void Register(Type serviceType)
        {
            if (serviceType == null) throw new ArgumentNullException(nameof(serviceType));
            if (!typeof(JsonRpcService).GetTypeInfo().IsAssignableFrom(serviceType.GetTypeInfo()))
                throw new ArgumentException("serviceType is not a derived type from JsonRpcService.");
            serviceTypes.Add(serviceType);
        }

        /// <summary>
        /// Registers all the exposed JSON PRC methods in the specified service object type.
        /// </summary>
        /// <typeparam name="TService">A subtype of <see cref="JsonRpcService"/>.</typeparam>
        public void Register<TService>() where TService : IJsonRpcService
        {
            Register(typeof(TService));
        }

        /// <summary>
        /// Adds a handler to intercept the JSON RPC requests.
        /// </summary>
        /// <param name="handler">The handler to be added.</param>
        /// <remarks>
        /// If there are multiple calls to this method, the last handler applied will be
        /// the fist to receive the request.
        /// </remarks>
        public void Intercept(Func<RequestContext, Func<Task>, Task> handler)
        {
            if (handler == null) throw new ArgumentNullException(nameof(handler));
            Intercept(next => (context =>
                handler(context, () => next(context)))
            );
        }

        /// <summary>
        /// Adds a middleware to intercept the JSON RPC requests.
        /// </summary>
        /// <param name="middleware">The middleware to be added.</param>
        /// <remarks>
        /// <para>If there are multiple calls to this method, the handler generated by the first applied middleware
        /// will be the fist to receive the request.</para>
        /// <para>Usually <see cref="Intercept(Func{RequestContext,Func{Task},Task})"/> is preferred to this overload.</para>
        /// </remarks>
        // Func(NextHandler) -> InterceptedHandler
        public void Intercept(Func<RequestHandler, RequestHandler> middleware)
        {
            if (middleware == null) throw new ArgumentNullException(nameof(middleware));
            interceptions.Add(middleware);
        }

        /// <summary>
        /// Builds an instance that implements <see cref="IJsonRpcServiceHost"/>.
        /// </summary>
        public IJsonRpcServiceHost Build()
        {
            var cr = ContractResolver ?? JsonRpcContractResolver.Default;
            var contract = cr.CreateServerContract(serviceTypes);
            var host = new JsonRpcServiceHost(contract)
            {
                ServiceFactory = ServiceFactory ?? DefaultServiceFactory.Default,
                MethodBinder = MethodBinder ?? JsonRpcMethodBinder.Default,
                Logger = (ILogger) LoggerFactory?.CreateLogger<JsonRpcServiceHost>() ?? NullLogger.Instance
            };
            host.BuildPipeline(interceptions);
            return host;
        }
    }

    /// <summary>
    /// The handler function that intercepts the client JSON RPC request.
    /// </summary>
    /// <param name="context">Current request context.</param>
    /// <returns>A task.</returns>
    public delegate Task RequestHandler(RequestContext context);

}
